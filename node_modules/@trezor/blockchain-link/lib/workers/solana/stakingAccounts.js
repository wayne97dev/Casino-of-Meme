"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSolanaStakingData = void 0;
const wallet_sdk_solana_1 = require("@everstake/wallet-sdk-solana");
const env_utils_1 = require("@trezor/env-utils");
const EVERSTAKE_VOTER_PUBKEYS = [
    '9QU2QSxhb24FUX3Tu2FpczXjpK3VYrvRudywSZaM29mF',
    'GkqYQysEGmuL6V2AJoNnWZUz2ZBGWhzQXsJiXm2CLKAN',
];
const getSolanaStakingData = async (descriptor, isTestnet, epoch, serverUrl) => {
    const network = isTestnet ? wallet_sdk_solana_1.Network.Devnet : wallet_sdk_solana_1.Network.Mainnet;
    const solanaClient = new wallet_sdk_solana_1.Solana(network, {
        rpc: serverUrl,
        userAgent: `Trezor Suite ${(0, env_utils_1.getSuiteVersion)()}`,
    });
    const delegations = await solanaClient.getDelegations(descriptor);
    if (!delegations || !delegations.result) {
        throw new Error('Failed to fetch delegations');
    }
    const { result: stakingAccounts } = delegations;
    return stakingAccounts
        .map(account => {
        const stakeAccount = account?.data;
        if (!stakeAccount)
            return;
        const stakeState = (0, wallet_sdk_solana_1.stakeAccountState)(stakeAccount, BigInt(epoch));
        const { state } = account?.data ?? {};
        if (!(0, wallet_sdk_solana_1.isStake)(state))
            return;
        if (state && 'fields' in state) {
            const { fields } = state;
            const voterPubkey = fields[1]?.delegation?.voterPubkey;
            if (!EVERSTAKE_VOTER_PUBKEYS.includes(voterPubkey))
                return;
            return {
                rentExemptReserve: fields[0]?.rentExemptReserve.toString(),
                stake: fields[1]?.delegation?.stake.toString(),
                status: stakeState,
            };
        }
    })
        .filter(account => account !== undefined);
};
exports.getSolanaStakingData = getSolanaStakingData;
//# sourceMappingURL=stakingAccounts.js.map