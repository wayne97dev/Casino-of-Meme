"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrezorConnect = exports.CoreInSuiteDesktop = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("events"));
const ERRORS = tslib_1.__importStar(require("@trezor/connect/lib/constants/errors"));
const events_2 = require("@trezor/connect/lib/events");
const factory_1 = require("@trezor/connect/lib/factory");
const utils_1 = require("@trezor/utils");
const connectSettings_1 = require("../connectSettings");
class CoreInSuiteDesktop {
    eventEmitter = new events_1.default();
    _settings;
    ws;
    messages;
    constructor() {
        this._settings = (0, connectSettings_1.parseConnectSettings)();
        this.messages = (0, utils_1.createDeferredManager)();
    }
    manifest(data) {
        this._settings = (0, connectSettings_1.parseConnectSettings)({
            ...this._settings,
            manifest: data,
        });
    }
    dispose() {
        this.eventEmitter.removeAllListeners();
        this._settings = (0, connectSettings_1.parseConnectSettings)();
        this.ws?.close();
        return Promise.resolve(undefined);
    }
    cancel(_error) { }
    async handshake() {
        const { promise, promiseId } = this.messages.create(1000);
        this.ws?.send(JSON.stringify({
            id: promiseId,
            type: events_2.POPUP.HANDSHAKE,
        }));
        try {
            await promise;
        }
        catch (err) {
            console.error(err);
            throw new Error('Handshake timed out');
        }
    }
    async init(settings = {}) {
        const newSettings = (0, connectSettings_1.parseConnectSettings)({
            ...this._settings,
            ...settings,
        });
        if (!newSettings.transports?.length) {
            newSettings.transports = ['BridgeTransport', 'WebUsbTransport'];
        }
        this._settings = newSettings;
        this.ws?.close();
        const wsOpen = (0, utils_1.createDeferred)(1000);
        this.ws = new WebSocket('ws://localhost:21335/connect-ws');
        this.ws.addEventListener('opened', () => {
            wsOpen.resolve();
        });
        this.ws.addEventListener('error', () => {
            wsOpen.reject(new Error('WebSocket error'));
            this.messages.rejectAll(new Error('WebSocket error'));
        });
        this.ws.addEventListener('message', (event) => {
            try {
                const data = JSON.parse(event.data);
                this.messages.resolve(data.id, data);
            }
            catch {
            }
        });
        this.ws.addEventListener('close', () => {
            wsOpen.reject(new Error('WebSocket closed'));
            this.messages.rejectAll(new Error('WebSocket closed'));
        });
        if (this.ws.readyState !== WebSocket.OPEN) {
            setTimeout(() => {
                if (this.ws?.readyState === WebSocket.OPEN) {
                    wsOpen.resolve();
                }
            }, 500);
            await wsOpen.promise;
        }
        return await this.handshake();
    }
    setTransports() {
        throw new Error('Unsupported right now');
    }
    async call(params) {
        try {
            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                await this.init();
            }
            await this.handshake();
            const { promise, promiseId } = this.messages.create();
            this.ws?.send(JSON.stringify({
                id: promiseId,
                type: events_2.IFRAME.CALL,
                payload: params,
            }));
            return promise;
        }
        catch (err) {
            return {
                success: false,
                payload: {
                    error: err.message,
                },
            };
        }
    }
    uiResponse(_response) {
        throw ERRORS.TypedError('Method_InvalidPackage');
    }
    requestLogin() {
        throw ERRORS.TypedError('Method_InvalidPackage');
    }
    disableWebUSB() {
        throw ERRORS.TypedError('Method_InvalidPackage');
    }
    requestWebUSBDevice() {
        throw ERRORS.TypedError('Method_InvalidPackage');
    }
    renderWebUSBButton() { }
}
exports.CoreInSuiteDesktop = CoreInSuiteDesktop;
const impl = new CoreInSuiteDesktop();
exports.TrezorConnect = (0, factory_1.factory)({
    eventEmitter: impl.eventEmitter,
    init: impl.init.bind(impl),
    call: impl.call.bind(impl),
    setTransports: impl.setTransports.bind(impl),
    manifest: impl.manifest.bind(impl),
    requestLogin: impl.requestLogin.bind(impl),
    uiResponse: impl.uiResponse.bind(impl),
    cancel: impl.cancel.bind(impl),
    dispose: impl.dispose.bind(impl),
});
//# sourceMappingURL=core-in-suite-desktop.js.map